// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package otel

import "fmt"
import "encoding/json"

type AggregationArgs_1 struct {
	// Boundaries corresponds to the JSON schema field "boundaries".
	Boundaries []float64 `json:"boundaries"`

	// MaxSize corresponds to the JSON schema field "max_size".
	MaxSize int `json:"max_size"`

	// RecordMinMax corresponds to the JSON schema field "record_min_max".
	RecordMinMax bool `json:"record_min_max"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AggregationArgs_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["boundaries"]; !ok || v == nil {
		return fmt.Errorf("field boundaries: required")
	}
	if v, ok := raw["max_size"]; !ok || v == nil {
		return fmt.Errorf("field max_size: required")
	}
	if v, ok := raw["record_min_max"]; !ok || v == nil {
		return fmt.Errorf("field record_min_max: required")
	}
	type Plain AggregationArgs_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AggregationArgs_1(plain)
	return nil
}

type Aggregation struct {
	// Args corresponds to the JSON schema field "args".
	Args AggregationArgs_1 `json:"args"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Aggregation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Aggregation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Aggregation(plain)
	return nil
}

type Attributes struct {
	// ServiceName corresponds to the JSON schema field "service.name".
	ServiceName string `json:"service.name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Attributes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["service.name"]; !ok || v == nil {
		return fmt.Errorf("field service.name: required")
	}
	type Plain Attributes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Attributes(plain)
	return nil
}

type Headers map[string]interface{}

type Otlp struct {
	// Certificate corresponds to the JSON schema field "certificate".
	Certificate *string `json:"certificate,omitempty"`

	// ClientCertificate corresponds to the JSON schema field "client_certificate".
	ClientCertificate *string `json:"client_certificate,omitempty"`

	// ClientKey corresponds to the JSON schema field "client_key".
	ClientKey *string `json:"client_key,omitempty"`

	// Compression corresponds to the JSON schema field "compression".
	Compression *string `json:"compression,omitempty"`

	// DefaultHistogramAggregation corresponds to the JSON schema field
	// "default_histogram_aggregation".
	DefaultHistogramAggregation *string `json:"default_histogram_aggregation,omitempty"`

	// Endpoint corresponds to the JSON schema field "endpoint".
	Endpoint string `json:"endpoint"`

	// Headers corresponds to the JSON schema field "headers".
	Headers Headers `json:"headers,omitempty"`

	// Insecure corresponds to the JSON schema field "insecure".
	Insecure *bool `json:"insecure,omitempty"`

	// Protocol corresponds to the JSON schema field "protocol".
	Protocol string `json:"protocol"`

	// TemporalityPreference corresponds to the JSON schema field
	// "temporality_preference".
	TemporalityPreference *string `json:"temporality_preference,omitempty"`

	// Timeout corresponds to the JSON schema field "timeout".
	Timeout *int `json:"timeout,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Otlp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["endpoint"]; !ok || v == nil {
		return fmt.Errorf("field endpoint: required")
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		return fmt.Errorf("field protocol: required")
	}
	type Plain Otlp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Otlp(plain)
	return nil
}

type Exporters struct {
	// Otlp corresponds to the JSON schema field "otlp".
	Otlp Otlp `json:"otlp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Exporters) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["otlp"]; !ok || v == nil {
		return fmt.Errorf("field otlp: required")
	}
	type Plain Exporters
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Exporters(plain)
	return nil
}

type Jaeger struct {
	// AgentHost corresponds to the JSON schema field "agent_host".
	AgentHost string `json:"agent_host"`

	// AgentPort corresponds to the JSON schema field "agent_port".
	AgentPort int `json:"agent_port"`

	// Endpoint corresponds to the JSON schema field "endpoint".
	Endpoint string `json:"endpoint"`

	// Password corresponds to the JSON schema field "password".
	Password string `json:"password"`

	// Protocol corresponds to the JSON schema field "protocol".
	Protocol string `json:"protocol"`

	// Timeout corresponds to the JSON schema field "timeout".
	Timeout int `json:"timeout"`

	// User corresponds to the JSON schema field "user".
	User string `json:"user"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Jaeger) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["agent_host"]; !ok || v == nil {
		return fmt.Errorf("field agent_host: required")
	}
	if v, ok := raw["agent_port"]; !ok || v == nil {
		return fmt.Errorf("field agent_port: required")
	}
	if v, ok := raw["endpoint"]; !ok || v == nil {
		return fmt.Errorf("field endpoint: required")
	}
	if v, ok := raw["password"]; !ok || v == nil {
		return fmt.Errorf("field password: required")
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		return fmt.Errorf("field protocol: required")
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		return fmt.Errorf("field timeout: required")
	}
	if v, ok := raw["user"]; !ok || v == nil {
		return fmt.Errorf("field user: required")
	}
	type Plain Jaeger
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Jaeger(plain)
	return nil
}

type JaegerRemote struct {
	// Endpoint corresponds to the JSON schema field "endpoint".
	Endpoint string `json:"endpoint"`

	// InitialSamplingRate corresponds to the JSON schema field
	// "initial_sampling_rate".
	InitialSamplingRate float64 `json:"initial_sampling_rate"`

	// PollingInterval corresponds to the JSON schema field "polling_interval".
	PollingInterval int `json:"polling_interval"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JaegerRemote) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["endpoint"]; !ok || v == nil {
		return fmt.Errorf("field endpoint: required")
	}
	if v, ok := raw["initial_sampling_rate"]; !ok || v == nil {
		return fmt.Errorf("field initial_sampling_rate: required")
	}
	if v, ok := raw["polling_interval"]; !ok || v == nil {
		return fmt.Errorf("field polling_interval: required")
	}
	type Plain JaegerRemote
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = JaegerRemote(plain)
	return nil
}

type Limits struct {
	// AttributeCountLimit corresponds to the JSON schema field
	// "attribute_count_limit".
	AttributeCountLimit int `json:"attribute_count_limit"`

	// AttributeValueLengthLimit corresponds to the JSON schema field
	// "attribute_value_length_limit".
	AttributeValueLengthLimit int `json:"attribute_value_length_limit"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Limits) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attribute_count_limit"]; !ok || v == nil {
		return fmt.Errorf("field attribute_count_limit: required")
	}
	if v, ok := raw["attribute_value_length_limit"]; !ok || v == nil {
		return fmt.Errorf("field attribute_value_length_limit: required")
	}
	type Plain Limits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Limits(plain)
	return nil
}

type LogRecordProcessorArgs struct {
	// ExportTimeout corresponds to the JSON schema field "export_timeout".
	ExportTimeout *int `json:"export_timeout,omitempty"`

	// Exporter corresponds to the JSON schema field "exporter".
	Exporter string `json:"exporter"`

	// MaxExportBatchSize corresponds to the JSON schema field
	// "max_export_batch_size".
	MaxExportBatchSize *int `json:"max_export_batch_size,omitempty"`

	// MaxQueueSize corresponds to the JSON schema field "max_queue_size".
	MaxQueueSize *int `json:"max_queue_size,omitempty"`

	// ScheduleDelay corresponds to the JSON schema field "schedule_delay".
	ScheduleDelay *int `json:"schedule_delay,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LogRecordProcessorArgs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exporter"]; !ok || v == nil {
		return fmt.Errorf("field exporter: required")
	}
	type Plain LogRecordProcessorArgs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LogRecordProcessorArgs(plain)
	return nil
}

type Processor struct {
	// Args corresponds to the JSON schema field "args".
	Args LogRecordProcessorArgs `json:"args"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Processor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Processor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Processor(plain)
	return nil
}

type LoggerProvider struct {
	// Exporters corresponds to the JSON schema field "exporters".
	Exporters Exporters `json:"exporters"`

	// LogRecordLimits corresponds to the JSON schema field "log_record_limits".
	LogRecordLimits Limits `json:"log_record_limits"`

	// LogRecordProcessors corresponds to the JSON schema field
	// "log_record_processors".
	LogRecordProcessors []Processor `json:"log_record_processors"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoggerProvider) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exporters"]; !ok || v == nil {
		return fmt.Errorf("field exporters: required")
	}
	if v, ok := raw["log_record_limits"]; !ok || v == nil {
		return fmt.Errorf("field log_record_limits: required")
	}
	if v, ok := raw["log_record_processors"]; !ok || v == nil {
		return fmt.Errorf("field log_record_processors: required")
	}
	type Plain LoggerProvider
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LoggerProvider(plain)
	return nil
}

type MetricReader struct {
	// Args corresponds to the JSON schema field "args".
	Args MetricReaderArgs_1 `json:"args"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type"`
}

type MetricReaderArgs_1 struct {
	// Exporter corresponds to the JSON schema field "exporter".
	Exporter *string `json:"exporter,omitempty"`

	// Host corresponds to the JSON schema field "host".
	Host *string `json:"host,omitempty"`

	// Interval corresponds to the JSON schema field "interval".
	Interval *int `json:"interval,omitempty"`

	// Port corresponds to the JSON schema field "port".
	Port *int `json:"port,omitempty"`

	// Timeout corresponds to the JSON schema field "timeout".
	Timeout *int `json:"timeout,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetricReader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain MetricReader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MetricReader(plain)
	return nil
}

type Selector struct {
	// InstrumentName corresponds to the JSON schema field "instrument_name".
	InstrumentName string `json:"instrument_name"`

	// InstrumentType corresponds to the JSON schema field "instrument_type".
	InstrumentType string `json:"instrument_type"`

	// MeterName corresponds to the JSON schema field "meter_name".
	MeterName string `json:"meter_name"`

	// MeterSchemaUrl corresponds to the JSON schema field "meter_schema_url".
	MeterSchemaUrl string `json:"meter_schema_url"`

	// MeterVersion corresponds to the JSON schema field "meter_version".
	MeterVersion string `json:"meter_version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Selector) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["instrument_name"]; !ok || v == nil {
		return fmt.Errorf("field instrument_name: required")
	}
	if v, ok := raw["instrument_type"]; !ok || v == nil {
		return fmt.Errorf("field instrument_type: required")
	}
	if v, ok := raw["meter_name"]; !ok || v == nil {
		return fmt.Errorf("field meter_name: required")
	}
	if v, ok := raw["meter_schema_url"]; !ok || v == nil {
		return fmt.Errorf("field meter_schema_url: required")
	}
	if v, ok := raw["meter_version"]; !ok || v == nil {
		return fmt.Errorf("field meter_version: required")
	}
	type Plain Selector
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Selector(plain)
	return nil
}

type ViewView struct {
	// Aggregation corresponds to the JSON schema field "aggregation".
	Aggregation Aggregation `json:"aggregation"`

	// AttributeKeys corresponds to the JSON schema field "attribute_keys".
	AttributeKeys []string `json:"attribute_keys"`

	// Description corresponds to the JSON schema field "description".
	Description string `json:"description"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ViewView) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aggregation"]; !ok || v == nil {
		return fmt.Errorf("field aggregation: required")
	}
	if v, ok := raw["attribute_keys"]; !ok || v == nil {
		return fmt.Errorf("field attribute_keys: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ViewView
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ViewView(plain)
	return nil
}

type ViewElement struct {
	// Selector corresponds to the JSON schema field "selector".
	Selector Selector `json:"selector"`

	// View corresponds to the JSON schema field "view".
	View ViewView `json:"view"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ViewElement) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["selector"]; !ok || v == nil {
		return fmt.Errorf("field selector: required")
	}
	if v, ok := raw["view"]; !ok || v == nil {
		return fmt.Errorf("field view: required")
	}
	type Plain ViewElement
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ViewElement(plain)
	return nil
}

type MeterProvider struct {
	// Exporters corresponds to the JSON schema field "exporters".
	Exporters Exporters `json:"exporters"`

	// MetricReaders corresponds to the JSON schema field "metric_readers".
	MetricReaders []MetricReader `json:"metric_readers"`

	// Views corresponds to the JSON schema field "views".
	Views []ViewElement `json:"views"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeterProvider) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exporters"]; !ok || v == nil {
		return fmt.Errorf("field exporters: required")
	}
	if v, ok := raw["metric_readers"]; !ok || v == nil {
		return fmt.Errorf("field metric_readers: required")
	}
	if v, ok := raw["views"]; !ok || v == nil {
		return fmt.Errorf("field views: required")
	}
	type Plain MeterProvider
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MeterProvider(plain)
	return nil
}

type Resource struct {
	// Attributes corresponds to the JSON schema field "attributes".
	Attributes Attributes `json:"attributes"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Resource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes: required")
	}
	type Plain Resource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Resource(plain)
	return nil
}

type ParentBased struct {
	// LocalParentNotSampled corresponds to the JSON schema field
	// "local_parent_not_sampled".
	LocalParentNotSampled string `json:"local_parent_not_sampled"`

	// LocalParentSampled corresponds to the JSON schema field "local_parent_sampled".
	LocalParentSampled string `json:"local_parent_sampled"`

	// RemoteParentNotSampled corresponds to the JSON schema field
	// "remote_parent_not_sampled".
	RemoteParentNotSampled string `json:"remote_parent_not_sampled"`

	// RemoteParentSampled corresponds to the JSON schema field
	// "remote_parent_sampled".
	RemoteParentSampled string `json:"remote_parent_sampled"`

	// Root corresponds to the JSON schema field "root".
	Root string `json:"root"`
}

type TracerProviderExporters_1 map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParentBased) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["local_parent_not_sampled"]; !ok || v == nil {
		return fmt.Errorf("field local_parent_not_sampled: required")
	}
	if v, ok := raw["local_parent_sampled"]; !ok || v == nil {
		return fmt.Errorf("field local_parent_sampled: required")
	}
	if v, ok := raw["remote_parent_not_sampled"]; !ok || v == nil {
		return fmt.Errorf("field remote_parent_not_sampled: required")
	}
	if v, ok := raw["remote_parent_sampled"]; !ok || v == nil {
		return fmt.Errorf("field remote_parent_sampled: required")
	}
	if v, ok := raw["root"]; !ok || v == nil {
		return fmt.Errorf("field root: required")
	}
	type Plain ParentBased
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ParentBased(plain)
	return nil
}

type TraceIDRatioBased struct {
	// Ratio corresponds to the JSON schema field "ratio".
	Ratio float64 `json:"ratio"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceIDRatioBased) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ratio"]; !ok || v == nil {
		return fmt.Errorf("field ratio: required")
	}
	type Plain TraceIDRatioBased
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TraceIDRatioBased(plain)
	return nil
}

type SamplerConfig struct {
	// AlwaysOff corresponds to the JSON schema field "always_off".
	AlwaysOff interface{} `json:"always_off"`

	// AlwaysOn corresponds to the JSON schema field "always_on".
	AlwaysOn interface{} `json:"always_on"`

	// JaegerRemote corresponds to the JSON schema field "jaeger_remote".
	JaegerRemote JaegerRemote `json:"jaeger_remote"`

	// ParentBased corresponds to the JSON schema field "parent_based".
	ParentBased ParentBased `json:"parent_based"`

	// TraceIdRatioBased corresponds to the JSON schema field "trace_id_ratio_based".
	TraceIdRatioBased TraceIDRatioBased `json:"trace_id_ratio_based"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SamplerConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["always_off"]; !ok {
		return fmt.Errorf("field always_off: required")
	}
	if _, ok := raw["always_on"]; !ok {
		return fmt.Errorf("field always_on: required")
	}
	if v, ok := raw["jaeger_remote"]; !ok || v == nil {
		return fmt.Errorf("field jaeger_remote: required")
	}
	if v, ok := raw["parent_based"]; !ok || v == nil {
		return fmt.Errorf("field parent_based: required")
	}
	if v, ok := raw["trace_id_ratio_based"]; !ok || v == nil {
		return fmt.Errorf("field trace_id_ratio_based: required")
	}
	type Plain SamplerConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.AlwaysOff != nil {
		return fmt.Errorf("field %s: must be null", "always_off")
	}
	if plain.AlwaysOn != nil {
		return fmt.Errorf("field %s: must be null", "always_on")
	}
	*j = SamplerConfig(plain)
	return nil
}

type SpanLimits struct {
	// AttributeCountLimit corresponds to the JSON schema field
	// "attribute_count_limit".
	AttributeCountLimit int `json:"attribute_count_limit"`

	// AttributeValueLengthLimit corresponds to the JSON schema field
	// "attribute_value_length_limit".
	AttributeValueLengthLimit int `json:"attribute_value_length_limit"`

	// EventAttributeCountLimit corresponds to the JSON schema field
	// "event_attribute_count_limit".
	EventAttributeCountLimit int `json:"event_attribute_count_limit"`

	// EventCountLimit corresponds to the JSON schema field "event_count_limit".
	EventCountLimit int `json:"event_count_limit"`

	// LinkAttributeCountLimit corresponds to the JSON schema field
	// "link_attribute_count_limit".
	LinkAttributeCountLimit int `json:"link_attribute_count_limit"`

	// LinkCountLimit corresponds to the JSON schema field "link_count_limit".
	LinkCountLimit int `json:"link_count_limit"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpanLimits) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attribute_count_limit"]; !ok || v == nil {
		return fmt.Errorf("field attribute_count_limit: required")
	}
	if v, ok := raw["attribute_value_length_limit"]; !ok || v == nil {
		return fmt.Errorf("field attribute_value_length_limit: required")
	}
	if v, ok := raw["event_attribute_count_limit"]; !ok || v == nil {
		return fmt.Errorf("field event_attribute_count_limit: required")
	}
	if v, ok := raw["event_count_limit"]; !ok || v == nil {
		return fmt.Errorf("field event_count_limit: required")
	}
	if v, ok := raw["link_attribute_count_limit"]; !ok || v == nil {
		return fmt.Errorf("field link_attribute_count_limit: required")
	}
	if v, ok := raw["link_count_limit"]; !ok || v == nil {
		return fmt.Errorf("field link_count_limit: required")
	}
	type Plain SpanLimits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpanLimits(plain)
	return nil
}

type TracerProvider struct {
	// Exporters corresponds to the JSON schema field "exporters".
	Exporters TracerProviderExporters_1 `json:"exporters"`

	// Sampler corresponds to the JSON schema field "sampler".
	Sampler *string `json:"sampler,omitempty"`

	// SamplerConfig corresponds to the JSON schema field "sampler_config".
	SamplerConfig *SamplerConfig `json:"sampler_config,omitempty"`

	// SpanLimits corresponds to the JSON schema field "span_limits".
	SpanLimits *SpanLimits `json:"span_limits,omitempty"`

	// SpanProcessors corresponds to the JSON schema field "span_processors".
	SpanProcessors []Processor `json:"span_processors"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TracerProvider) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exporters"]; !ok || v == nil {
		return fmt.Errorf("field exporters: required")
	}
	if v, ok := raw["span_processors"]; !ok || v == nil {
		return fmt.Errorf("field span_processors: required")
	}
	type Plain TracerProvider
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TracerProvider(plain)
	return nil
}

type SDK struct {
	// AttributeLimits corresponds to the JSON schema field "attribute_limits".
	AttributeLimits *Limits `json:"attribute_limits,omitempty"`

	// Disabled corresponds to the JSON schema field "disabled".
	Disabled bool `json:"disabled"`

	// LoggerProvider corresponds to the JSON schema field "logger_provider".
	LoggerProvider *LoggerProvider `json:"logger_provider,omitempty"`

	// MeterProvider corresponds to the JSON schema field "meter_provider".
	MeterProvider *MeterProvider `json:"meter_provider,omitempty"`

	// Propagators corresponds to the JSON schema field "propagators".
	Propagators []string `json:"propagators,omitempty"`

	// Resource corresponds to the JSON schema field "resource".
	Resource *Resource `json:"resource,omitempty"`

	// TracerProvider corresponds to the JSON schema field "tracer_provider".
	TracerProvider *TracerProvider `json:"tracer_provider,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SDK) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["disabled"]; !ok || v == nil {
		return fmt.Errorf("field disabled: required")
	}
	type Plain SDK
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SDK(plain)
	return nil
}

type OpenTelemetryConfiguration struct {
	// SchemeVersion corresponds to the JSON schema field "scheme_version".
	SchemeVersion float64 `json:"scheme_version"`

	// Sdk corresponds to the JSON schema field "sdk".
	Sdk SDK `json:"sdk"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenTelemetryConfiguration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["scheme_version"]; !ok || v == nil {
		return fmt.Errorf("field scheme_version: required")
	}
	if v, ok := raw["sdk"]; !ok || v == nil {
		return fmt.Errorf("field sdk: required")
	}
	type Plain OpenTelemetryConfiguration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OpenTelemetryConfiguration(plain)
	return nil
}

type Zipkin struct {
	// Endpoint corresponds to the JSON schema field "endpoint".
	Endpoint string `json:"endpoint"`

	// Timeout corresponds to the JSON schema field "timeout".
	Timeout int `json:"timeout"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Zipkin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["endpoint"]; !ok || v == nil {
		return fmt.Errorf("field endpoint: required")
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		return fmt.Errorf("field timeout: required")
	}
	type Plain Zipkin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Zipkin(plain)
	return nil
}
